/**
 * The WebContainer Public API allows you build custom applications on top of an in-browser Node.js runtime.
 *
 * Its main entrypoint is the {@link WebContainer} class.
 *
 * @packageDocumentation
 */
import type { FileSystemTree } from './entities';
export type { FileSystemTree, DirectoryNode, FileNode } from './entities';
/**
 * The main export of this library. An instance of `WebContainer` represents a runtime
 * ready to be used.
 */
export declare class WebContainer {
    /**
     * Gives access to the underlying file system.
     */
    fs: FileSystemAPI;
    /**
     * Spawns a process.
     *
     * @param command - The program to be executed.
     * @param args - The command-line arguments for the program.
     *
     * @example
     * ```
     * const install = await webcontainer.spawn('npm', ['i']);
     * ```
     */
    spawn(command: string, args: string[], options?: SpawnOptions): Promise<WebContainerProcess>;
    /**
     * Spawns a process without command-line arguments.
     *
     * @param command - The program to be executed.
     *
     * @example
     * ```
     * const install = await webcontainer.spawn('yarn');
     * ```
     */
    spawn(command: string, options?: SpawnOptions): Promise<WebContainerProcess>;
    /**
     * Listens for `'port'` events, which are emitted when a port is open or closed by some process.
     */
    on(event: 'port', listener: PortListener): Unsubscribe;
    /**
     * Listens for `'server-ready'` events, emitted when a running server is listening for incoming
     * connections and ready to answer requests.
     */
    on(event: 'server-ready', listener: ServerReadyListener): Unsubscribe;
    /**
     * Listens for `'error'` events, emitted when an internal error is triggered.
     */
    on(event: 'error', listener: ErrorListener): Unsubscribe;
    /**
     * Mounts a tree of files into the filesystem.
     *
     * @param tree
     * @param options.mountPoint - Specifies a nested path where the tree should be mounted.
     */
    mount(tree: FileSystemTree, options?: {
        mountPoint?: string;
    }): Promise<void>;
    /**
     * Destroys the WebContainer instance and releases its resources.
     */
    teardown(): void;
    /**
     * Boots a WebContainer. Only a single instance of WebContainer can be booted.
     */
    static boot(): Promise<WebContainer>;
}
/**
 * @param port - The port on which the server is listening.
 * @param type - The new status of the port.
 * @param url - The url where the server can be accessed.
 */
export declare type PortListener = (port: number, type: 'open' | 'close', url: string) => void;
/**
 * @param port - The port on which the readied server is listening.
 * @param url - The url where the server can be accessed.
 */
export declare type ServerReadyListener = (port: number, url: string) => void;
/**
 * @param error - The emitted error.
 */
export declare type ErrorListener = (error: {
    message: string;
}) => void;
/**
 * A representation of a directory entry,
 * see {@link https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#class-fsdirent | the Node.js API}.
 */
export interface DirEnt<T> {
    name: T;
    isFile(): boolean;
    isDirectory(): boolean;
}
/**
 * Interface to interact directly with the WebContainer filesystem. Modeled after
 * {@link https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#promises-api | `fs.promises`} in Node.
 */
export interface FileSystemAPI {
    readdir(path: string, options: 'buffer' | {
        encoding: 'buffer';
        withFileTypes?: false;
    }): Promise<Uint8Array[]>;
    readdir(path: string, options?: {
        encoding?: BufferEncoding | null;
        withFileTypes?: false;
    } | BufferEncoding | null): Promise<string[]>;
    readdir(path: string, options: {
        encoding: 'buffer';
        withFileTypes: true;
    }): Promise<DirEnt<Uint8Array>[]>;
    readdir(path: string, options: {
        encoding?: BufferEncoding | null;
        withFileTypes: true;
    }): Promise<DirEnt<string>[]>;
    readFile(path: string, encoding?: null): Promise<Uint8Array>;
    readFile(path: string, encoding: BufferEncoding): Promise<string>;
    writeFile(path: string, data: string | Uint8Array, options?: string | {
        encoding?: string | null;
    } | null): Promise<void>;
    mkdir(path: string, options?: {
        recursive?: false;
    }): Promise<void>;
    mkdir(path: string, options: {
        recursive: true;
    }): Promise<string>;
    rm(path: string, options?: {
        force?: boolean;
        recursive?: boolean;
    }): Promise<void>;
}
/**
 * A running process spawned in a {@link WebContainer}.
 */
export interface WebContainerProcess {
    /**
     * A promise for the exit code of the process.
     */
    exit: Promise<number>;
    /**
     * An input stream for the attached pseudoterminal device.
     */
    input: WritableStream<string>;
    /**
     * A stream that receives all terminal output, including the stdout and stderr emitted by the spawned process
     * _and_ its descendants.
     *
     * Can be disabled by setting {@link SpawnOptions | `output` } to `false`.
     */
    output: ReadableStream<string>;
    /**
     * Kills the process.
     */
    kill(): void;
    /**
     * Resizes the attached terminal.
     */
    resize(dimensions: {
        cols: number;
        rows: number;
    }): void;
}
/**
 * Options that control process spawning.
 */
export interface SpawnOptions {
    /**
     * Environment variables to set for the process.
     */
    env?: Record<string, string | number | boolean>;
    /**
     * When set to false, no terminal output is sent back to the process,
     * and the {@link WebContainerProcess#output | `output`} stream will never produce any chunks.
     */
    output?: boolean;
    /**
     * The size of the attached terminal.
     */
    terminal?: {
        cols: number;
        rows: number;
    };
}
export declare type Unsubscribe = () => void;
declare type BufferEncoding = Exclude<string, 'buffer'>;
